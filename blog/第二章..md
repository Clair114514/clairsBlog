# 第 2 章：信息的表示和处理 - 详细总结

## 2.1 核心观点

计算机中的所有信息——包括程序、数据、甚至内存地址——都是由一串**比特（bits）** 表示的。区分这些比特序列所代表含义（是整数、字符还是指令）的唯一方法是**上下文（Context）**。本章重点研究三种最重要的数字表示：**无符号整数**、**补码整数**和**IEEE浮点数**。

## 2.2 信息存储

### 2.2.1 十六进制表示法

*   由于二进制表示太冗长，十进制与二进制转换麻烦，常用**十六进制（Hexadecimal）** 作为二进制位的简洁表示。
*   每个十六进制数字对应 4 个二进制位（`0x0` ~ `0xF` -> `0000` ~ `1111`）。
*   在 C 语言中，以 `0x` 或 `0X` 开头的数字常量是十六进制值（如 `0xFA1D37B`）。

| 十六进制数字 | 十进制值 | 二进制值 | 十六进制数字 | 十进制值 | 二进制值 |
| :----------- | :------- | :------- | :----------- | :------- | :------- |
| `0`          | 0        | `0000`   | `8`          | 8        | `1000`   |
| `1`          | 1        | `0001`   | `9`          | 9        | `1001`   |
| `2`          | 2        | `0010`   | `A`          | 10       | `1010`   |
| `3`          | 3        | `0011`   | `B`          | 11       | `1011`   |
| `4`          | 4        | `0100`   | `C`          | 12       | `1100`   |
| `5`          | 5        | `0101`   | `D`          | 13       | `1101`   |
| `6`          | 6        | `0110`   | `E`          | 14       | `1110`   |
| `7`          | 7        | `0111`   | `F`          | 15       | `1111`   |

### 2.2.2 字数据大小

*   **字长（Word Size）**：指明指针数据的标称大小，决定了**虚拟地址空间的最大大小**（例如，32位字长 -> $2^{32}$ 字节 = 4 GB；64位字长 -> $2^{64}$ 字节）。
*   C 语言数据类型的大小在不同字长的机器上可能不同。ISO C99 引入了固定大小的数据类型（如 `int32_t`, `uint64_t`）来保证可移植性。

| C 声明             | 32 位机器 | 64 位机器 | 备注                                            |
| :----------------- | :-------- | :-------- | :---------------------------------------------- |
| `char`             | 1         | 1         |                                                 |
| `short`            | 2         | 2         |                                                 |
| `int`              | 4         | 4         |                                                 |
| `long`             | 4         | 8         | **大小随字长变化**                              |
| `float`            | 4         | 4         |                                                 |
| `double`           | 8         | 8         |                                                 |
| **指针（如 `*`）** | **4**     | **8**     | **大小随字长变化，这是 32/64 位程序的关键区别** |

### 2.2.3 寻址和字节顺序

*   多字节对象在内存中存储为连续的字节序列，对象的地址是所用字节中最小的地址。
*   **字节顺序（端序，Endianness）**：
    *   **小端法（Little Endian）**：最低有效字节存储在最低内存地址（Intel 兼容机常用）。
    *   **大端法（Big Endian）**：最高有效字节存储在最低内存地址（IBM, Oracle, 早期 Sun）。
    *   网络传输数据时需考虑端序问题，通常使用**网络字节序（大端法）** 标准。

### 2.2.4 表示字符串

*   字符串被编码为以 `null`（值 `0`）字符结尾的字符数组。
*   使用 **ASCII 码**或 **Unicode (UTF-8)** 等标准编码。文本数据比二进制数据具有更强的平台独立性。

### 2.2.5 布尔代数与位级运算

*   布尔代数基于二进制值 `0` (False) 和 `1` (True)。
*   C 语言支持位级布尔运算：`&` (AND), `|` (OR), `~` (NOT), `^` (XOR)。
*   位级运算常用于**掩码（Mask）** 操作，从字中选出指定的位集合（如 `x & 0xFF` 获取最低有效字节）。

### 2.2.6 C 语言中的逻辑运算

*   C 语言还提供逻辑运算：`&&` (AND), `||` (OR), `!` (NOT)。
*   **逻辑运算与位级运算的区别**：
    1.  逻辑运算认为所有**非零值**均为 `True`，**零**为 `False`，结果总是 `0` 或 `1`。
    2.  逻辑运算存在**短路（Short-circuit）** 求值特性。

## 2.3 整数表示

### 2.3.1 无符号数编码

*   只能表示非负数。
*   对向量 $\vec{x} = [x_{w-1}, x_{w-2}, ..., x_0]$：
    $B2U_w(\vec{x}) = \sum_{i=0}^{w-1} x_i \cdot 2^i$
*   **范围**：$0$ ~ $2^w - 1$ (UMax$_w$)

### 2.3.2 补码编码

*   可表示负数、零和正数，是最常见的有符号整数表示方式。
*   对向量 $\vec{x} = [x_{w-1}, x_{w-2}, ..., x_0]$：
    $B2T_w(\vec{x}) = -x_{w-1} \cdot 2^{w-1} + \sum_{i=0}^{w-2} x_i \cdot 2^i$
    *   最高有效位 $x_{w-1}$ 也称为**符号位**，权重为 $-2^{w-1}$。
*   **范围**：$-2^{w-1}$ (TMin$_w$) ~ $2^{w-1} - 1$ (TMax$_w$)。**注意**：|TMin| = |TMax| + 1，范围不对称。
*   最重要的数字的位模式和数值：

| 字长 w | 值          | 十六进制     | 二进制（补码）          |
| :----- | :---------- | :----------- | :---------------------- |
| 16     | TMin$_{16}$ | `0x8000`     | `1000 0000 0000 0000`   |
| 16     | TMax$_{16}$ | `0x7FFF`     | `0111 1111 1111 1111`   |
| 16     | -1          | `0xFFFF`     | `1111 1111 1111 1111`   |
| 32     | TMin$_{32}$ | `0x80000000` | `1000 ... 0000` (31个0) |
| 32     | TMax$_{32}$ | `0x7FFFFFFF` | `0111 ... 1111` (31个1) |
| 32     | UMax$_{32}$ | `0xFFFFFFFF` | `1111 ... 1111` (32个1) |

### 2.3.3 有符号数与无符号数之间的转换

*   C 语言中，有符号数和无符号数之间的转换遵循**底层的位模式不变**的原则。
*   转换函数（$T$: 补码，$U$: 无符号）：
    *   $T2U_w(x) = \begin{cases} x + 2^w, & x < 0 \\ x, & x \ge 0 \end{cases}$
    *   $U2T_w(u) = \begin{cases} u, & u \le TMax_w \\ u - 2^w, & u > TMax_w \end{cases}$
*   **重要提示**：包含有符号和无符号数的表达式会**隐式地将有符号数转换为无符号数**，这可能导致意想不到的结果（例如 `-1 > 0U` 为 `true`）。

### 2.3.4 扩展与截断

*   **扩展（零扩展/符号扩展）**：
    *   **无符号数**：**零扩展**，在表示左边添加 0。
    *   **补码数**：**符号扩展**，在表示左边添加最高有效位（符号位）的副本。
*   **截断**：丢弃高位字节，可能改变数值（溢出）。
    *   **无符号数**：$x' = x \mod 2^k$
    *   **补码数**：$x' = U2T_k(x \mod 2^k)$

## 2.4 整数运算

### 2.4.1 无符号加法

*   定义操作 $+_w^u$：$x +_w^u y = \begin{cases} x + y, & x+y < 2^w \\ x+y-2^w, & 2^w \le x+y < 2^{w+1} \end{cases}$
*   **检测无符号加法溢出**：当 $s = x +_w^u y$ 且 $s < x$（或 $s < y$) 时，发生溢出。

### 2.4.2 补码加法

*   定义操作 $+_w^t$：$x +_w^t y = U2T_w(T2U_w(x) +_w^u T2U_w(y))$
*   更直观的形式：$x +_w^t y = \begin{cases} x+y+2^w, & x+y < TMin_w \\ x+y, & TMin_w \le x+y \le TMax_w \\ x+y-2^w, & x+y > TMax_w \end{cases}$
*   **检测补码加法溢出**：
    *   **正溢出**：$x>0, y>0, s\le0$
    *   **负溢出**：$x<0, y<0, s\ge0$

### 2.4.3 乘以常数

*   编译器会尝试用移位和加法运算的组合来替代乘以常数。
*   乘以 2 的幂 $k$ 可以用左移 $k$ 位来实现（`x << k`）。
*   例如：`x * 14` = `(x<<3) + (x<<2) + (x<<1)` = `(x<<4) - (x<<1)`

### 2.4.4 除以 2 的幂

*   除以 2 的幂可以用右移来实现，但需注意舍入。
*   **无符号数**：**逻辑右移**。总是向 0 舍入。 `x >> k` 产生 $\lfloor x/2^k \rfloor$。
*   **补码数**：**算术右移**。
    *   对于 $x \ge 0$，行为与无符号相同，向 0 舍入。
    *   对于 $x < 0$，简单移位是**向下舍入**（向 $-\infty$），但 C 标准要求整数除法向 0 舍入。
    *   **正确的舍入方法**：使用**偏置（Biasing）** 技术。`(x + (1<<k) - 1) >> k` 产生 $\lceil x/2^k \rceil$。

## 2.5 浮点数

### 2.5.1 IEEE 浮点表示

*   用 $V = (-1)^s \times M \times 2^E$ 的形式来表示一个数：
    *   **符号（s）**：`0` 表示正，`1` 表示负。
    *   **尾数（M）**：一个二进制小数，范围通常在 $[1.0, 2.0)$ 或 $[0, 1.0)$。
    *   **阶码（E）**：对浮点数加权，是 2 的幂。
*   浮点数的位表示被划分为三个字段：
    1.  一个符号位 `s`。
    2.  `k` 位的阶码字段 `exp`，编码指数 `E`。
    3.  `n` 位的小数字段 `frac`，编码尾数 `M`。

| 格式   | 总位数 | 符号位 `s` | 阶码位 `k` | 小数位 `n` | 偏置量（Bias） |
| :----- | :----- | :--------- | :--------- | :--------- | :------------- |
| 单精度 | 32     | 1          | 8          | 23         | 127            |
| 双精度 | 64     | 1          | 11         | 52         | 1023           |

*   根据 `exp` 的值，被编码的值分为三种情况：
    1.  **规格化的值（`exp` 既非全 0 也非全 1）**：
        *   $E = exp - Bias$
        *   $M = 1 + f$ (**隐含的以 1 开头**)
    2.  **非规格化的值（`exp` 全 0）**：
        *   $E = 1 - Bias$
        *   $M = f$ （没有隐含的 1）
        *   用于表示 $0.0$ 和非常接近 $0.0$ 的数（**逐渐下溢**）。
    3.  **特殊值（`exp` 全 1）**：
        *   如果 `frac` 全 0：表示**无穷大**（$\infty$），由溢出产生。
        *   如果 `frac` 非 0：表示 **NaN (Not a Number)**，表示不是实数的结果（如 $\sqrt{-1}$）。

### 2.5.2 舍入（Rounding）

*   浮点运算只能近似表示实数运算，因此需要舍入。
*   **IEEE 浮点格式定义了 4 种舍入方式**：
    | 方式           | 1.40 | 1.60 | 1.50 | 2.50 | -1.50 |
    | :------------- | :--- | :--- | :--- | :--- | :---- |
    | **向偶数舍入** | 1    | 2    | 2    | 2    | -2    |
    | **向零舍入**   | 1    | 1    | 1    | 2    | -1    |
    | **向下舍入**   | 1    | 1    | 1    | 2    | -2    |
    | **向上舍入**   | 2    | 2    | 2    | 3    | -1    |
*   **向偶数舍入（Round-to-even）** 是默认方式，它能在大多数现实情况下避免统计偏差。

### 2.5.3 浮点运算

*   浮点运算被定义为：$Round(x \odot y)$，即对真实计算结果进行舍入后的结果。
*   **浮点运算的特性**：
    *   可交换。
    *   **不可结合**（由于舍入和溢出），例如：`(3.14+1e10)-1e10 != 3.14+(1e10-1e10)`。
    *   **不可分配**。
    *   满足单调性。

### 2.5.4 C 语言中的浮点数

*   `float` 和 `double` 类型通常对应 IEEE 单精度和双精度。
*   **类型转换**：
    *   `int` -> `float`：不会溢出，但可能被舍入。
    *   `int`/`float` -> `double`：保留精确值。
    *   `double` -> `float`：可能溢出为 $\infty$ 或舍入。
    *   `float`/`double` -> `int`：向零舍入。如果值超出 `int` 范围，结果未定义（通常得到 TMin$_w$）。
