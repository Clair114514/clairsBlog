*   # 第2章 信息的表示和处理
    
    ## 1. 信息存储基础
    
    ### 1.1 基本概念
    
    - **位(bit)**：最小信息单位，0或1
    - **字节(byte)**：8位，最小可寻址内存单位
    - **字长(word size)**：指针数据的标称大小，决定虚拟地址空间
      - 32位机器：虚拟地址空间4GB (2^32)
      - 64位机器：虚拟地址空间16EB (2^64)
    
    ### 1.2 十六进制表示法
    
    ```
    十进制: 0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
    十六进制: 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    二进制: 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
    ```
    
    **转换规则**：
    
    - 二进制→十六进制：每4位二进制 = 1位十六进制
    - 例：101101112 = B716
    
    ### 1.3 寻址和字节顺序
    
    **大端法 vs 小端法**：
    
    ```
    数值 0x01234567 在内存中的存储：
    
    大端法 (Big Endian)：     小端法 (Little Endian)：
    地址 0x100: 01           地址 0x100: 67
    地址 0x101: 23           地址 0x101: 45  
    地址 0x102: 45           地址 0x102: 23
    地址 0x103: 67           地址 0x103: 01
    ```
    
    **影响场景**：
    
    1. 网络数据传输
    2. 阅读机器级代码
    3. 规避类型系统的程序
    
    ### 1.4 C语言数据类型
    
    ```c
    // 典型32位机器
    char:          1字节  范围 -128 ~ 127
    short:         2字节  范围 -32,768 ~ 32,767
    int:           4字节  范围 -2,147,483,648 ~ 2,147,483,647
    long:          4字节  (32位程序) 或 8字节 (64位程序)
    unsigned int:  4字节  范围 0 ~ 4,294,967,295
    
    // 固定大小类型
    int32_t:       4字节
    int64_t:       8字节
    uint32_t:      4字节 (无符号)
    ```
    
    ## 2. 布尔代数和位级运算
    
    ### 2.1 布尔运算
    
    ```
    AND (&): 0&0=0, 0&1=0, 1&0=0, 1&1=1
    OR  (|): 0|0=0, 0|1=1, 1|0=1, 1|1=1  
    XOR (^): 0^0=0, 0^1=1, 1^0=1, 1^1=0
    NOT (~): ~0=1, ~1=0
    ```
    
    ### 2.2 位级运算示例
    
    ```c
    // 掩码操作
    x & 0xFF        // 提取x的最低字节
    x | 0xFF        // 设置x的最低字节为全1
    x ^ x           // 得到0
    ~x + 1          // 等价于-x
    
    // 实用技巧
    x & (x-1)       // 清除x最右边的1
    x | (x-1)       // 将x最右边的0及其右边全部设为1
    ```
    
    ### 2.3 逻辑运算 vs 位级运算
    
    ```c
    // 逻辑运算 (&&, ||, !)
    !0x41           // 结果：0 (逻辑假)
    !!0x41          // 结果：1 (逻辑真)
    0x69 && 0x55    // 结果：1
    
    // 位级运算 (&, |, ^, ~)  
    ~0x41           // 结果：0xBE
    0x69 & 0x55     // 结果：0x41
    ```
    
    ### 2.4 移位运算
    
    ```c
    // 左移：丢弃高位，右端补0
    x << k          // 等价于 x * 2^k (可能溢出)
    
    // 右移：
    // 逻辑右移：左端补0
    // 算术右移：左端补符号位
    x >> k          // 对于有符号数：x / 2^k (向下取整)
    ```
    
    ## 3. 整数表示详解
    
    ### 3.1 无符号数编码
    
    **定义**：对w位向量 x = [x_{w-1}, x_{w-2}, ..., x_0]
    
    ```
    B2U_w(x) = Σ(i=0 to w-1) x_i * 2^i
    ```
    
    **特性**：
    
    - 取值范围：[0, 2^w - 1]
    - 每个值都有唯一编码
    - 最小值：000...0 (二进制) = 0
    - 最大值：111...1 (二进制) = UMax_w = 2^w - 1
    
    **示例**（w=4）：
    
    ```
    [0001] → 0×8 + 0×4 + 0×2 + 1×1 = 1
    [1010] → 1×8 + 0×4 + 1×2 + 0×1 = 10
    [1111] → 1×8 + 1×4 + 1×2 + 1×1 = 15
    ```
    
    ### 3.2 补码编码（核心重点）
    
    **定义**：对w位向量 x = [x_{w-1}, x_{w-2}, ..., x_0]
    
    ```
    B2T_w(x) = -x_{w-1} * 2^{w-1} + Σ(i=0 to w-2) x_i * 2^i
    ```
    
    **关键特性**：
    
    - 取值范围：[TMin_w, TMax_w] = [-2^{w-1}, 2^{w-1} - 1]
    - **范围不对称**：|TMin| = |TMax| + 1
    - 符号位权重为负：-2^{w-1}
    - 每个值都有唯一编码
    
    **重要数值**（w=4示例）：
    
    ```
    TMin_4 = [1000] = -8    // 最小值
    TMax_4 = [0111] = 7     // 最大值  
    -1     = [1111] = -8+4+2+1 = -1
    0      = [0000] = 0
    ```
    
    **特殊性质**：
    
    - TMin是自己的加法逆元：-TMin = TMin（因为+8超出表示范围）
    - -1的位模式全为1
    - 0的位模式全为0
    
    ### 3.3 有符号数与无符号数转换
    
    **核心原则：位模式保持不变，只改变解释方式**
    
    **补码→无符号数 (T2U)**：
    
    ```
    T2U_w(x) = {
        x,           x ≥ 0
        x + 2^w,     x < 0
    }
    ```
    
    **无符号数→补码 (U2T)**：
    
    ```
    U2T_w(u) = {
        u,           u ≤ TMax_w
        u - 2^w,     u > TMax_w
    }
    ```
    
    **转换示例**（w=16）：
    
    ```c
    short sx = -12345;        // 补码：0xCFC7
    unsigned short usx = sx;  // 无符号：53191 (相同位模式)
    // 关系：-12345 + 65536 = 53191
    ```
    
    **C语言隐式转换规则**：
    
    - 有符号数和无符号数混合运算时，有符号数被转换为无符号数
    - 可能导致意外结果：
    
    ```c
    -1 < 0U         // 结果：0 (假)，因为-1被转换为UMax
    ```
    
    ### 3.4 扩展和截断
    
    #### 3.4.1 零扩展（无符号数）
    
    ```c
    // 16位 → 32位
    unsigned short us = 53191;  // 0x0000CFC7
    unsigned u = us;            // 0x0000CFC7 (前面补0)
    ```
    
    #### 3.4.2 符号扩展（补码）
    
    ```c
    // 16位 → 32位  
    short s = -12345;           // 0xCFC7
    int i = s;                  // 0xFFFFCFC7 (前面补符号位1)
    ```
    
    **符号扩展规则**：复制符号位到新增的高位
    
    #### 3.4.3 截断
    
    **无符号数截断**：
    
    ```
    结果 = x mod 2^k
    ```
    
    **补码截断**：
    
    ```
    结果 = U2T_k(x mod 2^k)
    ```
    
    **示例**：
    
    ```c
    int x = 53191;              // 32位：0x0000CFC7
    short sx = (short)x;        // 16位：0xCFC7 = -12345
    ```
    
    ## 4. 整数运算详解
    
    ### 4.1 无符号加法
    
    **定义**：
    
    ```
    x +_w^u y = {
        x + y,         x + y < 2^w      (正常)
        x + y - 2^w,   x + y ≥ 2^w      (溢出)
    }
    ```
    
    **溢出检测**：
    
    ```c
    int uadd_ok(unsigned x, unsigned y) {
        unsigned sum = x + y;
        return sum >= x;  // 溢出时 sum < x
    }
    ```
    
    **加法逆元**：
    
    ```
    -x_w^u = {
        x,        x = 0
        2^w - x,  x > 0
    }
    ```
    
    ### 4.2 补码加法（重点）
    
    **定义**：
    
    ```
    x +_w^t y = {
        x + y - 2^w,  x + y ≥ 2^{w-1}     (正溢出)
        x + y,        -2^{w-1} ≤ x+y < 2^{w-1}  (正常)
        x + y + 2^w,  x + y < -2^{w-1}    (负溢出)
    }
    ```
    
    **溢出检测**：
    
    ```c
    int tadd_ok(int x, int y) {
        int sum = x + y;
        int pos_over = x > 0 && y > 0 && sum <= 0;
        int neg_over = x < 0 && y < 0 && sum >= 0;
        return !pos_over && !neg_over;
    }
    ```
    
    **补码的非（加法逆元）**：
    
    ```
    -x_w^t = {
        TMin_w,  x = TMin_w
        -x,      x > TMin_w
    }
    ```
    
    **位级实现技巧**：
    
    ```c
    // 方法1：取反加1
    -x ≡ ~x + 1
    
    // 方法2：从右往左，遇到第一个1之前的位取反
    // 例：x = [10110000] → -x = [01010000]
    ```
    
    ### 4.3 整数乘法
    
    **无符号乘法**：
    
    ```
    x *_w^u y = (x * y) mod 2^w
    ```
    
    **补码乘法**：
    
    ```
    x *_w^t y = U2T_w((x * y) mod 2^w)
    ```
    
    **关键性质**：无符号和补码乘法的位级表示相同
    
    **乘法溢出检测**：
    
    ```c
    int tmult_ok(int x, int y) {
        int p = x * y;
        return !x || p/x == y;  // 利用除法检验
    }
    ```
    
    ### 4.4 乘除法优化
    
    #### 4.4.1 乘以2的幂
    
    ```c
    x << k  ≡  x * 2^k  // 左移k位
    ```
    
    #### 4.4.2 除以2的幂
    
    **无符号除法**：
    
    ```c
    x >> k  ≡  x / 2^k  // 逻辑右移，向下取整
    ```
    
    **补码除法**：
    
    ```c
    // 向下取整（C语言除法）
    x >> k  ≡  ⌊x / 2^k⌋  // 算术右移
    
    // 向零取整（数学除法）
    (x + (1<<k) - 1) >> k  ≡  ⌈x / 2^k⌉  // 先加偏置
    ```
    
    **编译器优化示例**：
    
    ```c
    // 原代码
    y = x * 14;
    // 优化后（14 = 8 + 4 + 2）
    y = (x << 3) + (x << 2) + (x << 1);
    // 或者（14 = 16 - 2）
    y = (x << 4) - (x << 1);
    ```
    
    ## 5. 浮点数表示详解
    
    ### 5.1 二进制小数
    
    ```
    二进制 101.101₂ = 1×2² + 0×2¹ + 1×2⁰ + 1×2⁻¹ + 0×2⁻² + 1×2⁻³
                   = 4 + 0 + 1 + 0.5 + 0 + 0.125 = 5.625₁₀
    ```
    
    **有限精度问题**：
    
    - 十进制0.1无法用二进制小数精确表示
    - 0.1 ≈ 0.00011001100110011...₂（无限循环）
    
    ### 5.2 IEEE 754浮点格式
    
    **基本形式**：V = (-1)ˢ × M × 2ᴱ
    
    **字段组成**：
    
    ```
    单精度 (32位)：[s(1)] [exp(8)] [frac(23)]
    双精度 (64位)：[s(1)] [exp(11)] [frac(52)]
    ```
    
    #### 5.2.1 规格化值
    
    **条件**：exp ≠ 000...0 且 exp ≠ 111...1
    
    **计算**：
    
    - E = e - Bias，其中 Bias = 2^{k-1} - 1
    - M = 1 + f（隐含前导1）
    - 单精度：Bias = 127，E ∈ [-126, 127]
    - 双精度：Bias = 1023，E ∈ [-1022, 1023]
    
    **示例**（单精度）：
    
    ```
    位模式：0 10000010 01000000000000000000000
    s = 0（正数）
    exp = 130₁₀，E = 130 - 127 = 3
    frac = 0.25₁₀，M = 1.25
    值 = (+1) × 1.25 × 2³ = 10.0
    ```
    
    #### 5.2.2 非规格化值
    
    **条件**：exp = 000...0
    
    **计算**：
    
    - E = 1 - Bias（注意不是-Bias）
    - M = f（无隐含前导1）
    - 用途：表示0和接近0的小数
    
    **特殊值**：
    
    - +0.0：s=0, exp=000...0, frac=000...0
    - -0.0：s=1, exp=000...0, frac=000...0
    
    #### 5.2.3 特殊值
    
    **条件**：exp = 111...1
    
    **类型**：
    
    - 无穷大：frac = 000...0
      - +∞：s=0
      - -∞：s=1
    - NaN：frac ≠ 000...0
    
    ### 5.3 浮点数示例分析
    
    **8位格式示例**（k=4, n=3, Bias=7）：
    
    ```
    位模式    类型        E    M     值
    0000000   非规格化   -6   0     0
    0000001   非规格化   -6   1/8   1/512
    0000111   非规格化   -6   7/8   7/512
    0001000   规格化     -6   1     1/64
    0111000   规格化      0   1     1
    1110111   规格化      7   15/8  240
    1111000   特殊值      -   -     +∞
    ```
    
    ### 5.4 舍入方法
    
    #### 5.4.1 向偶数舍入（默认）
    
    **规则**：舍入到最近值，中间值舍入到偶数
    
    **示例**：
    
    ```
    1.5 → 2（2是偶数）
    2.5 → 2（2是偶数）
    3.5 → 4（4是偶数）
    ```
    
    **二进制示例**：
    
    ```
    10.00110₂ 舍入到1位小数：
    中间值，最低有效位为0（偶数）→ 10.0₂
    10.10110₂ 舍入到1位小数：
    中间值，最低有效位为0（偶数）→ 10.1₂
    ```
    
    #### 5.4.2 其他舍入方式
    
    - **向零舍入**：正数向下，负数向上
    - **向下舍入**：总是向负无穷方向
    - **向上舍入**：总是向正无穷方向
    
    ### 5.5 浮点运算
    
    #### 5.5.1 基本原则
    
    IEEE标准规定：浮点运算结果 = Round(精确结果)
    
    #### 5.5.2 浮点加法特性
    
    ```c
    // 交换律：成立
    x + y == y + x
    
    // 结合律：不成立！
    (3.14 + 1e10) - 1e10 == 0.0
    3.14 + (1e10 - 1e10) == 3.14
    ```
    
    #### 5.5.3 浮点乘法特性
    
    ```c
    // 交换律：成立
    x * y == y * x
    
    // 结合律：不成立
    (1e20 * 1e20) * 1e-20 == +∞
    1e20 * (1e20 * 1e-20) == 1e20
    
    // 分配律：不成立
    1e20 * (1e20 - 1e20) == 0.0
    1e20 * 1e20 - 1e20 * 1e20 == NaN
    ```
    
    #### 5.5.4 单调性（重要性质）
    
    ```c
    // 加法单调性
    a ≥ b ⇒ x + a ≥ x + b  (除了NaN)
    
    // 乘法单调性
    a ≥ b ∧ c ≥ 0 ⇒ a * c ≥ b * c
    a ≥ b ∧ c ≤ 0 ⇒ a * c ≤ b * c
    ```
    
    ### 5.6 C语言中的浮点数
    
    #### 5.6.1 类型转换规则
    
    ```c
    int → float    // 可能舍入，不会溢出
    int → double   // 精确转换
    float → double // 精确转换
    double → float // 可能舍入或溢出为±∞
    float/double → int // 向零舍入，可能溢出
    ```
    
    #### 5.6.2 特殊值处理
    
    ```c
    #define POS_INFINITY (1.0/0.0)
    #define NEG_INFINITY (-1.0/0.0)
    #define NEG_ZERO (-1.0/INFINITY)
    ```
    
    ## 6. 实际编程中的陷阱和技巧
    
    ### 6.1 常见错误
    
    #### 6.1.1 有符号/无符号混合
    
    ```c
    // 危险代码
    unsigned length = 0;
    for (int i = 0; i <= length - 1; i++) {  // length-1变成很大的无符号数
        // 导致内存错误
    }
    
    // 修正
    for (int i = 0; i < (int)length; i++) {
        // 安全
    }
    ```
    
    #### 6.1.2 整数溢出
    
    ```c
    // 内存分配漏洞
    void* ptr = malloc(count * size);  // count * size可能溢出
    
    // 安全检查
    if (count > 0 && size > SIZE_MAX / count) {
        // 溢出，拒绝分配
        return NULL;
    }
    ```
    
    #### 6.1.3 浮点精度问题
    
    ```c
    // 错误：浮点比较
    if (x == 0.1) { ... }  // 0.1无法精确表示
    
    // 正确：容差比较
    if (fabs(x - 0.1) < 1e-9) { ... }
    ```
    
    ### 6.2 位操作技巧
    
    #### 6.2.1 常用位操作
    
    ```c
    // 检查奇偶
    x & 1                    // 奇数返回1，偶数返回0
    
    // 交换两数（不推荐，仅作演示）
    x ^= y; y ^= x; x ^= y;
    
    // 计算绝对值（仅限补码）
    int abs(int x) {
        int mask = x >> 31;   // 符号位扩展
        return (x + mask) ^ mask;
    }
    
    // 快速模运算（当模数是2的幂时）
    x % 8  ≡  x & 7         // 仅对非负数
    ```
    
    #### 6.2.2 掩码操作
    
    ```c
    // 提取字段
    #define GET_BYTE(x, n) (((x) >> (8*(n))) & 0xFF)
    
    // 设置字段
    #define SET_BYTE(x, n, b) ((x) | ((b) << (8*(n))))
    
    // 清除字段
    #define CLEAR_BYTE(x, n) ((x) & ~(0xFF << (8*(n))))
    ```
    
    ### 6.3 编译器优化案例
    
    #### 6.3.1 强度折减
    
    ```c
    // 编译器会自动优化
    y = x * 15;
    // 优化为：
    y = (x << 4) - x;  // 15 = 16 - 1
    
    y = x / 8;
    // 优化为（无符号）：
    y = x >> 3;
    // 优化为（有符号）：
    y = (x + 7) >> 3;  // 向零舍入
    ```
    
    #### 6.3.2 循环优化
    
    ```c
    // 原代码
    for (int i = 0; i < n; i++) {
        sum += i * 3;
    }
    
    // 编译器可能优化为
    int temp = 0;
    for (int i = 0; i < n; i++) {
        sum += temp;
        temp += 3;
    }
    ```
    
    ## 7. 安全编程指导原则
    
    ### 7.1 整数安全
    
    1. **避免有符号/无符号混合**：明确类型转换
    2. **检查溢出**：特别是用于内存分配的计算
    3. **使用固定宽度类型**：int32_t, uint64_t等
    4. **边界检查**：数组访问和循环边界
    
    ### 7.2 浮点安全
    
    1. **避免直接相等比较**：使用容差比较
    2. **检查特殊值**：NaN, ±∞
    3. **注意精度损失**：大数加小数
    4. **考虑舍入误差累积**：迭代计算中
    
    ### 7.3 代码审查要点
    
    1. **类型转换**：隐式转换是否安全
    2. **边界条件**：最大值、最小值、零值
    3. **溢出检查**：算术运算结果范围
    4. **精度要求**：浮点计算是否满足需求
